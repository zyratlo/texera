/**
 * JavaCC compilation options
 */
options {
    /**
     * Multiple instances of the parser might be required, thus the parser
     * should not be compiled as static (made up by static methods)
     */
    STATIC = false;
    /**
     * Use Unicode Input since Java's implementation of String, Character and
     * console input uses unicode. Compiling without using UNICODE_INPUT might
     * lead to unexpected results if you are using the wrong encoding.
     * Please make sure to provide a source with unicode characters, wrapping
     * the input in a Java Reader such as FileReader or InputStreamReader
     * if necessary.
     */
    UNICODE_INPUT = true;
    /**
     * The TextQL language is case-insensitive
     */
    IGNORE_CASE = true;
}

PARSER_BEGIN(TextQLParser)

package edu.uci.ics.textdb.textql.languageparser;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Consumer;
import org.apache.commons.lang3.builder.EqualsBuilder;

/**
 * Implementation of a parser for the TextQL query language.
 * Please check README.md for grammar specification
 * 
 * @author Flavio Bayer
 */
public class TextQLParser{

    /**
     * Statement class and subclasses (SelectStatement, CreateViewStatement)
     * Each Statement class has an id attribute. Statement subclasses have
     * specific fields related to their function. These classes have no methods.
     * They are used only as containers to move data.
     * Statement --+ SelectStatement
     *             + CreateViewStatement
     */
    static public abstract class Statement {
        //Identifier of each Statement
        public String id;
        
        public Statement() {
            this(null);
        }
        public Statement(String id) {
            this.id = id;
        }
        @Override
        public boolean equals(Object other) {
            if (other == null) { return false; }
            if (other.getClass() != this.getClass()) { return false; }
            Statement statement = (Statement) other;
            return new EqualsBuilder()
                        .append(id, statement.id)
                        .isEquals();
        }
    }
    static public class SelectStatement extends Statement {
        //projectAll is set to true when '*' is used on the fields to be projected, as in "SELECT * ..."
        public Boolean projectAll;
        //projectedFields is the list of fields to be projected if it is specified as in "SELECT a, b, c ...""
        public List<String> projectedFields;
        //extractPredicate is the predicate for used for data extraction as keyword match in "KEYWORDMATCH(a,"word")"
        public ExtractPredicate extractPredicate;
        //fromClause is the identifier of a view, as in "SELECT... FROM viewName"
        public String fromClause;
        //limitClause is the maximum number of tuples to be returned, as in "SELECT...FROM... LIMIT 5"
        public Integer limitClause;
        //offsetClause is the number of tuples to be skipped before returning, as in "SELECT...FROM... OFFSET 5"
        public Integer offsetClause;

        public SelectStatement() {
            this(null, null, null, null, null, null, null);
        }
        public SelectStatement(String id, Boolean projectAll,
                              List<String> projectedFields, ExtractPredicate extractPredicate,
                              String fromClause, Integer limitClause, Integer offsetClause) {
            super(id);
            this.projectAll = projectAll;
            this.projectedFields = projectedFields;
            this.extractPredicate = extractPredicate;
            this.fromClause = fromClause;
            this.limitClause = limitClause;
            this.offsetClause = offsetClause;
        }
        @Override
        public boolean equals(Object other) {
            if (other == null) { return false; }
            if (other.getClass() != this.getClass()) { return false; }
            SelectStatement selectStatement = (SelectStatement) other;
            return new EqualsBuilder()
                        .appendSuper(super.equals(selectStatement))
                        .append(projectAll, selectStatement.projectAll)
                        .append(projectedFields, selectStatement.projectedFields)
                        .append(extractPredicate, selectStatement.extractPredicate)
                        .append(fromClause, selectStatement.fromClause)
                        .append(limitClause, selectStatement.limitClause)
                        .append(offsetClause, selectStatement.offsetClause)
                        .isEquals();
        }
    }
    static public class CreateViewStatement extends Statement {
        /**
         * subStatement is the statement to which the create view statement creates an alias for
         * e.g. in "CREATE VIEW v AS SELECT *FROM t; the view with id 'v' will have the
         * select statement "SELECT *FROM t" as subStatement (in a SlectStatement object)
         */
        public Statement subStatement;
        public CreateViewStatement() {
            this(null, null);
        }
        public CreateViewStatement(String id, Statement subStatement) {
            super(id);
            this.subStatement = subStatement;
        }
        @Override
        public boolean equals(Object other) {
            if (other == null) { return false; }
            if (other.getClass() != this.getClass()) { return false; }
            CreateViewStatement createViweClass = (CreateViewStatement) other;
            return new EqualsBuilder()
                        .appendSuper(super.equals(createViweClass))
                        .append(subStatement, createViweClass.subStatement)
                        .isEquals();
        }
    }

    /**
     * ExtractPredicate class and its subclasses such as KeywordExtractPredicate
     * Subclasses have specific fields related to its extraction functionalities
     * These classes have no methods. They are used only as containers
     * ExtractPredicate --+ KeywordExtractPredicate
     */
    static public abstract class ExtractPredicate {
        @Override
        public boolean equals(Object other) {
            if (other == null) { return false; }
            if (other.getClass() != getClass()) { return false; }
            //since ExtractPredicate has no attributes, there's nothing to compare but the class itself
            return true;
        }
    }
    static public class KeywordExtractPredicate extends ExtractPredicate {
        //matchingFields is the list of fields which the keyword search should be performed
        public List<String> matchingFields;
        //keywords is the keyword(s) used for keyword search
        public String keywords;
        //matchingType specifies the type of keyword search to be done
        public String matchingType;
    
        public KeywordExtractPredicate() {
          this(null, null, null);
        }
        public KeywordExtractPredicate(List<String> matchingFields, String keywords, String matchingType) {
            this.matchingFields = matchingFields;
            this.keywords = keywords;
            this.matchingType = matchingType;
        }
        @Override
        public boolean equals(Object other) {
            if (other == null) { return false; }
            if (other.getClass() != getClass()) { return false; }
            KeywordExtractPredicate keywordExtractPredicate = (KeywordExtractPredicate) other;
            return new EqualsBuilder()
                    .appendSuper(super.equals(keywordExtractPredicate))
                    .append(matchingFields, keywordExtractPredicate.matchingFields)
                    .append(keywords, keywordExtractPredicate.keywords)
                    .append(matchingType, keywordExtractPredicate.matchingType)
                    .isEquals();
        }
    }

    /**
     * Generates a unique deterministic sequence of ids for new statements
     * The id follows the format "_sidX", where X is an incremental hexadecimal
     *  integer without padding starting from 0.
     * e.g. "_lid0", "_lid1", ..., "_lid9", "_lida", ..., "_lidf", "_lid10", ...
     * @return The generated id
     */
    private int currentStatementIdSequence = 0;
    private String getNewStatementId(){
        return "_sid" + Integer.toString(currentStatementIdSequence++, 16);
    }
}

PARSER_END(TextQLParser)

/*
 *    Skipped Tokens
 *  The following are tokens that should be ignored/skipped.
 */
SKIP : { " " | "\n" | "\r" | "\t" | "\f" }
/**
 * Basic Tokens - Reserved Words
 */
TOKEN : { < CREATE : "CREATE" > }
TOKEN : { < DIRECTORY : "DIRECTORY" > }
TOKEN : { < VIEW : "VIEW" > }
TOKEN : { < SELECT : "SELECT" > }
TOKEN : { < EXTRACT : "EXTRACT" > }
TOKEN : { < FROM : "FROM" > }
TOKEN : { < AS : "AS" > }
TOKEN : { < LIMIT : "LIMIT" > }
TOKEN : { < OFFSET : "OFFSET" > }
TOKEN : { < JOIN : "JOIN" > }
TOKEN : { < WHERE : "WHERE" > }
TOKEN : { < OUTPUT : "OUTPUT" > }
TOKEN : { < INSERT : "INSERT" > }
TOKEN : { < INTO : "INTO" > }
TOKEN : { < VALUES : "VALUES" > }
TOKEN : { < KEYWORDMATCH : "KEYWORDMATCH" > }
/**
 *    Basic Tokens - Comparison operators
 */
TOKEN : { < ASSIGN: "="> }
TOKEN : { < LT: "<" > }
TOKEN : { < GT: ">" > }
TOKEN : { < EQ: "==" > }
TOKEN : { < LE: "<=" > }
TOKEN : { < GE: ">=" > }
TOKEN : { < NE: "!=" > }
/**
 * Basic Tokens - Other 1-Character tokens
 */
TOKEN : { < LPAREN: "(" > }
TOKEN : { < RPAREN: ")" > }
TOKEN : { < LBRACE: "{" > }
TOKEN : { < RBRACE: "}" > }
TOKEN : { < LBRACKET: "[" > }
TOKEN : { < RBRACKET: "]" > }
TOKEN : { < SEMICOLON: ";" > }
TOKEN : { < COMMA: "," > }
TOKEN : { < DOT: "." > }
TOKEN : { < STAR : "*" > }



/*
 *    Literal Tokens
 */
/**
 *    NUMBER_LITERAL - Matches a number in decimal format
 *  The token matched is composed by an optional ('-') character followed by
 *  (d [ . [d]]) or ('.' d), where d is a digit string, and the bracket content
 *  is optional.
 *  The following are matching examples
 *      0
 *      -0
 *      12
 *      123.
 *      -78.90
 *      -.789
 */
TOKEN : { < NUMBER_LITERAL : ("-")? ((["0"-"9"])+ ("." (["0"-"9"])*)? | "." (["0"-"9"])+) > }
/**
 *    STRING_LITERAL - Matches a quoted string (it may contains escaped quotes)
 *  The token matched is composed by a quote ('"') followed by any character except
 *  for another quote('"'), unless it is escaped('\"') and ended with a quote('"').
 *  The following are matching examples
 *      ""
 *      "abc"
 *      "de f"
 *      "de\" f"
 *      "d\"e\"f"
 *      "de\n f"
 *      "de\\ f"
 */    
TOKEN : { < STRING_LITERAL : "\"" ( "\\" ~[] | ~["\""] )* "\"" > }
/**
 *    REGEX_LITERAL - Matches a regex string delimited by forward slashes
 *                  (it may contains escaped forward slashes)
 *  The token matched is composed by a forward slash ('/') followed by any
 *  character except for another forward slash ('/'), unless it is escaped ('\/')
 *  and ended with a forward slash ('/').
 *  The following are matching examples
 *      //
 *      /abc/
 *      /de f/
 *      /d\/e/
 *      /d\n/
 *      /d\/e\/f/
 *      /"/
 */   
TOKEN : { < REGEX_LITERAL : "/" ( "\\" ~[] | ~["/"] )* "/" > }
/**
 *    IDENTIFIER_LITERAL - Matches an identifier string(e.g. for variable names)
 *  The token matched is composed by an alphabetic character followed by
 *  alphanumeric characters.
 *  The following are matching examples
 *      i
 *      id
 *      id0
 *      i0d
 */ 
TOKEN : { < IDENTIFIER_LITERAL : ["a"-"z"](["a"-"z","0"-"9"])*  > }


/*
 *    Wrappers for literal tokens
 *    Those are simple methods that convert raw Tokens into formated data
 */
/**
 * Consume a NUMBER_LITERAL from the input and convert it to a Double.
 * Examples of valid input: 0, -0, 12, 123., -78.90, -.789
 * @throws NumberFormatException if the conversion to Double fails
 * @return The double representation of the NUMBER_LITERAL
 */
double numberLiteralToDouble():
{
    String numberString;
}
{
    numberString = numberLiteralToString()
    {
        return Double.parseDouble(numberString);
    }
}
/**
 * Consume a NUMBER_LITERAL from the input and convert it to an Integer.
 * Examples of valid input: 0, -0, 12
 * @throws NumberFormatException if the conversion to Integer fails
 * @return The integer representation of the NUMBER_LITERAL
 */
int numberLiteralToInteger():
{
    String numberString;
}
{
    numberString = numberLiteralToString()
    {
        return Integer.parseInt(numberString);
    }
}
/**
 * Consume a NUMBER_LITERAL from the input and convert it to a String.
 * Examples of valid input: 0, -0, 12, 123., -78.90, -.789
 * @return The String representation of the NUMBER_LITERAL
 */
String numberLiteralToString():
{
    Token token;
}
{
    token = <NUMBER_LITERAL>
    {
        return token.image;
    }
}

/**
 * Consume a STRING_LITERAL from input and return convert it to String 
 * Escaped quotes and delimiter quotes are removed
 * Examples of REGEX_LITERAL and the output String(without delimiter simple-quotes):
 *      ""        = > '' (empty)
 *      "abc"     = > 'abc'
 *      "de f"    = > 'de f'
 *      "de\" f"  = > 'de" f'
 *      "d\"e\"f" = > 'd"e"f'
 *      "de\n f"  = > 'de\n f'
 *      "de\\f"   = > 'de\\f'
 * @return The String representation of the STRING_LITERAL
 */
String stringLiteralToString():
{
    Token token;
}
{
    token = <STRING_LITERAL>
    {
        String string = token.image;
        String unquotedString = string.substring(1, string.length()-1);
        String escapedUnquotedString = unquotedString.replace("\\\"", "\"");
        return escapedUnquotedString;
    }
}
/**
 * Consume a REGEX_LITERAL from input and return convert it to String 
 * Escaped slashes and delimiter slashes are removed
 * Examples of REGEX_LITERAL and the output String(without delimiter quotes):
 *      //         = > "" (empty)
 *      /abc/      = > "abc"
 *      /de f/     = > "de f"
 *      /d\/e/     = > "d/e"
 *      /d\n/      = > "d\n"
 *      /d\/e\/f/  = > "d/e/f"
 *      /"/        = > "\"" (a quote)
 * @return The String representation of the REGEX_LITERAL
 */
String regexLiteralToString():
{
    Token token;
}
{
    token = <REGEX_LITERAL>
    {
        String regex = token.image;
        String unslashedRegex = regex.substring(1, regex.length()-1);
        String escapedUnslashedRegex = unslashedRegex.replace("\\/", "/");
        return escapedUnslashedRegex;
    }
}
/**
 * Consume an IDENTIFIER_LITERAL from input and convert it to String
 * Examples: i, id, id0, i0d
 * @return The String representation of the IDENTIFIER_LITERAL
 */
String identifierLiteralToString():
{
    Token token;
}
{
    token = <IDENTIFIER_LITERAL>
    {
      return token.image;
    }
}

/*
 *    List of literal tokens separated by commas
 */
/**
 * Consume a list of IDENTIFIER_LITERAL(one or more) from input and convert it to List<String>
 * Example: "i,id,id0,i0d" (without quote) = > { "i", "id", "id0", "i0d" }
 * Grammar: <IdentifierLiteral> ("," <IdentifierLiteral>)* 
 * @return The List<String> representation of the list of IDENTIFIER_LITERAL
 */
List<String> identifierListToListString():
{
    String identifier;
    List<String> identifiers = new ArrayList<String>();
}
{
    identifier = identifierLiteralToString() { identifiers.add(identifier); } 
    (
        <COMMA> identifier = identifierLiteralToString() { identifiers.add(identifier); }
    )*
    {
        return identifiers;
    }
}


/*
 * Declarations of statement rules
 */
/**
 * Consume the whole input and generates a list containing the declared statement
 * Grammar: (<Statement>)* <EOF>
 * @param statementConsumer The consumer is called after each statement is parsed
 * @return The List<Statement> representation of the whole input
 */
List<Statement> mainStatementList(Consumer<Statement> statementConsumer) : 
{
    List<Statement> statements = new ArrayList();
    Statement newStatement;
}
{
    // Look for zero or more occurrences of Statement
    (
        // Parse one statement
        newStatement = statement() { statements.add(newStatement); } 
        {
            // Call the statement consumer (if we have one) after each statement is parsed
            if(statementConsumer!=null) { 
                statementConsumer.accept(newStatement);
            }
        }
    )*
    //Consume the End Of File
    <EOF>
    //Return the list of statements generated
    {
        return statements;
    }
}

/**
 * Consume one statement declaration form the input and generates a Statement
 * object with the parsed data. The type of statement can either be either
 * SelectStatement or CreateViewStatement
 * Grammar: ( <SelectStatement> | <CreateViewStatement> ) ";"
 * @return The Statement representation of the next statement declaration
 */
Statement statement() : 
{
    Statement newStatement;
}
{
    // extract one of the types of statement
    (
            newStatement = selectStatement() 
        |
            newStatement = createViewStatement()
    )
    <SEMICOLON>
    // return generated Statement
    {
        return newStatement;
    }
}

/**
 * Consume a "CREATE VIEW" statement declaration form the input and generate a
 * CreateViewStatement object with the parsed data
 * Examples of valid input:
 *         CREATE VIEW viewname0 AS <SelectStatement>
 * Grammar: "CREATE" "VIEW" <Identifier>
 *          "AS" ( <SelectStatement> )
 * @return The CreateViewStatement representation of the next statement declaration
 */
CreateViewStatement createViewStatement() : 
{
    CreateViewStatement createViewStatement = new CreateViewStatement();
    Statement subStatement;
    String viewName;
}
{
    // parse CREATE VIEW viewName AS
    <CREATE>
    <VIEW>
    viewName = identifierLiteralToString() { createViewStatement.id = viewName; }
    <AS>
    // parse inner statement: either a SelectStatement or another CreateViewStatement
    (
        subStatement = selectStatement()
    ){ createViewStatement.subStatement = subStatement; }
    // return generated CreateViewStatement
    {
        return createViewStatement;
    }
}

/**
 * Consume a "SELECT" statement declaration form the input and generate a
 * SelectStatement object with the parsed data
 * Examples of valid input:
 *         SELECT * FROM t
 *         SELECT a,b,c FROM t LIMIT 1 OFFSET 8
 *         EXTRACT KEYWORDMATCH(g0, "key1") FROM k
 *         SELECT a EXTRACT KEYWORDMATCH(g0, "key1") FROM k
 *         SELECT * EXTRACT KEYWORDMATCH([h6,h7,k8,k9], "key1", conjunction) FROM k LIMIT 1 OFFSET 8
 * Grammar: (
 *              "SELECT" ( "*" | <identifierListToListString> ) ("EXTRACT" <ExtractPredicate>)?
 *            |
 *              "EXTRACT" <ExtractPredicate>
 *          )
 *          "FROM" <Identifier>
 *          ("LIMIT" <Number> )?
 *          ("OFFSET" <Number> )?
 * @return The SelectStatement representation of the next statement declaration
 */  
SelectStatement selectStatement() : 
{
    SelectStatement selectStatement = new SelectStatement();
    selectStatement.id = getNewStatementId();
    List<String> identifiers;
    String fromClause;
    Integer limitClause;
    Integer offsetClause;
    ExtractPredicate extractPredicate;
}
{
    // parse SELECT clause or/and EXTRACT clause
    (
            // parse SELECT clause only or parse SELECT clause and EXTRACT clause
            (
                  // parse SELECT clause
                <SELECT> 
                ( 
                        <STAR> { selectStatement.projectAll = true; } // SELECT *
                    | 
                        identifiers = identifierListToListString() { selectStatement.projectedFields = identifiers; } // SELECT a,b,...
                )
                // parse EXTRACT clause (optional)
                (
                    <EXTRACT> extractPredicate = extractPredicate() { selectStatement.extractPredicate = extractPredicate; } // EXTRACT extractPredicate
                )?
            )
        |
            // parse EXTRACT clause only
            <EXTRACT> extractPredicate = extractPredicate() { selectStatement.extractPredicate = extractPredicate; } // EXTRACT only
    )
    // parse FROM field
    <FROM> fromClause = identifierLiteralToString() { selectStatement.fromClause = fromClause; }
    // parse LIMIT field(optional)
    (
      <LIMIT> limitClause = numberLiteralToInteger() { selectStatement.limitClause = limitClause; }
    )?
    // parse OFFSET field(optional)
    (
      <OFFSET> offsetClause = numberLiteralToInteger() { selectStatement.offsetClause = offsetClause; }
    )?
    // return generated SelectStatement
    {
        return selectStatement;
    }
}


/*
 * Declaration of extraction predicates rules
 */
/**
 * Consume one extract predicate form the input and generate a ExtractPredicate
 * object with the parsed data
 * The kind of extract predicate can either be only KeywordExtractPredicate
 * Grammar: ExtractPredicate := (<KeywordExtractPredicate>)
 * @return The ExtractPredicate representation of the next extract predicate
 */
ExtractPredicate extractPredicate() : 
{
    ExtractPredicate extractPredicate;
}
{
    // extract one of the types of ExtractPedicates
    (
        extractPredicate = extractKeywordMatchPredicate()
    )
    // return generated KeywordExtractPredicate
    {
        return extractPredicate;
    }
}

/**
 * Consume a keyword extract predicate form the input and generate a
 * KeywordExtractPredicate object with the parsed data
 * Examples of valid input:
 *         KEYWORDMATCH(g0, "key1")
 *         KEYWORDMATCH([g6,g7,h8,i9], "key")
 *         KEYWORDMATCH(g3, "key4", substring)
 * Grammar: "KEYWORDMATCH("
 *            ( <Identifier> | "[" <identifierList> "]")
 *            "," <String>
 *            ("," <Identifier>)?
 *          ")"
 * @return The KeywordExtractPredicate representation of the next statement declaration
 */
KeywordExtractPredicate extractKeywordMatchPredicate() : 
{
    KeywordExtractPredicate extractPredicate = new KeywordExtractPredicate();
    List<String> matchingFields;
    String matchingField;
    String keywords;
    String matchingType;
}
{
    <KEYWORDMATCH>
    <LPAREN>
        // parse the match fields(either a field or list of field)
        (
                  // parse only only field identifier
                matchingField = identifierLiteralToString() { matchingFields = Arrays.asList(matchingField); }
            | 
                  // parse the list of fields between brackets
                <LBRACKET> matchingFields = identifierListToListString() <RBRACKET>
        ) { extractPredicate.matchingFields = matchingFields; }
        // parse the keyword as a string
        <COMMA> keywords = stringLiteralToString() { extractPredicate.keywords = keywords; }
        // parse the match type as an identifier(optional)
        (
            <COMMA> matchingType = identifierLiteralToString() { extractPredicate.matchingType = matchingType; }
        )?
    <RPAREN>
    // return generated KeywordExtractPredicate
    {
        return extractPredicate;
    }
}


